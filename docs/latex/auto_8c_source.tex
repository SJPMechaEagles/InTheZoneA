\subsection{auto.\+c}
\label{auto_8c_source}\index{src/auto.\+c@{src/auto.\+c}}

\begin{DoxyCode}
00001 
00014 \textcolor{preprocessor}{#include "auto.h"}
00015 \textcolor{preprocessor}{#include "main.h"}
00016 
00017 \textcolor{comment}{/*}
00018 \textcolor{comment}{ * Runs the user autonomous code. This function will be started in its own task}
00019 \textcolor{comment}{ * with the default priority and stack size whenever the robot is enabled via}
00020 \textcolor{comment}{ * the Field Management System or the VEX Competition Switch in the autonomous}
00021 \textcolor{comment}{ * mode. If the robot is disabled or communications is lost,  the autonomous}
00022 \textcolor{comment}{ * task will be stopped by the kernel. Re-enabling the robot will restart the}
00023 \textcolor{comment}{ * task, not re-start it from where it left off.}
00024 \textcolor{comment}{ *}
00025 \textcolor{comment}{ * Code running in the autonomous task cannot access information from the VEX}
00026 \textcolor{comment}{ * Joystick. However, the autonomous function can be invoked from another task}
00027 \textcolor{comment}{ * if a VEX Competition Switch is not available, and it can access joystick}
00028 \textcolor{comment}{ * information if called in this way.}
00029 \textcolor{comment}{ *}
00030 \textcolor{comment}{ * The autonomous task may exit, unlike operatorControl() which should never}
00031 \textcolor{comment}{ * exit. If it does so, the robot will await a switch to another mode or}
00032 \textcolor{comment}{ * disable/enable cycle.}
00033 \textcolor{comment}{ */}
00034 \textcolor{keywordtype}{void} autonomous() \{
00035   init_slew();
00036 
00037   delay(10);
00038   printf(\textcolor{stringliteral}{"auto\(\backslash\)n"});
00039   \textcolor{comment}{// How far the left wheels have gone}
00040   \textcolor{keywordtype}{int} counts\_drive\_left;
00041   \textcolor{comment}{// How far the right wheels have gone}
00042   \textcolor{keywordtype}{int} counts\_drive\_right;
00043   \textcolor{comment}{// The average distance traveled forward}
00044   \textcolor{keywordtype}{int} counts\_drive;
00045 
00046   \textcolor{comment}{// Reset the integrated motor controllers}
00047   imeReset(MID_LEFT_DRIVE);
00048   imeReset(MID_RIGHT_DRIVE);
00049   \textcolor{comment}{// Set initial values for how far the wheels have gone}
00050   imeGet(MID_LEFT_DRIVE, &counts\_drive\_left);
00051   imeGet(MID_RIGHT_DRIVE, &counts\_drive\_right);
00052   counts\_drive = counts\_drive\_left + counts\_drive\_right;
00053   counts\_drive /= 2;
00054 
00055   \textcolor{comment}{// Deploy claw}
00056   \textcolor{keywordflow}{while} (analogRead(SECONDARY_LIFTER_POT_PORT) < DEPLOY_HEIGHT) \{
00057 
00058     set_secondary_lifter_motors(MAX_SPEED);
00059   \}
00060   set_secondary_lifter_motors(0);
00061 
00062   \textcolor{keywordflow}{while} (analogRead(SECONDARY_LIFTER_POT_PORT) > LOWEST_HEIGHT) \{
00063     set_secondary_lifter_motors(MIN_SPEED);
00064   \}
00065   set_secondary_lifter_motors(0);
00066 
00067   \textcolor{comment}{// Grab pre-load cone}
00068   close_claw();
00069   delay(300);
00070   set_claw_motor(0);
00071 
00072   \textcolor{keywordflow}{while} (analogRead(SECONDARY_LIFTER_POT_PORT) < MAX_HEIGHT) \{
00073     set_secondary_lifter_motors(MAX_SPEED);
00074   \}
00075   set_secondary_lifter_motors(0);
00076   \textcolor{comment}{// Raise the lifter}
00077   \textcolor{keywordflow}{while} (analogRead(MAIN_LIFTER_POT) < MOBILE_GOAL_HEIGHT) \{
00078     set_main_lifter_motors(MAX_SPEED);
00079   \}
00080   set_main_lifter_motors(0);
00081   \textcolor{comment}{// Drive towards the goal}
00082 
00083   lower_intake();
00084   delay(300);
00085   set_intake_motor(0);
00086 
00087   \textcolor{keywordflow}{while} (counts\_drive < MOBILE_GOAL_DISTANCE) \{
00088     set_side_speed(BOTH, 127);
00089     \textcolor{comment}{// Restablish the distance traveled}
00090     imeGet(MID_LEFT_DRIVE, &counts\_drive\_left);
00091     imeGet(MID_RIGHT_DRIVE, &counts\_drive\_right);
00092     counts\_drive = counts\_drive\_left + counts\_drive\_right;
00093     counts\_drive /= 2;
00094   \}
00095   \textcolor{comment}{// Stop moving}
00096   set_side_speed(BOTH, 0);
00097   delay(1000);
00098 
00099   raise_intake();
00100   delay(300);
00101   set_intake_motor(0);
00102 
00103   \textcolor{comment}{// Drop the cone on the goal}
00104   open_claw();
00105   delay(1000);
00106 
00107   \textcolor{keywordtype}{int} ang = 0;
00108   \textcolor{keywordflow}{while} (ang < HALF_ROTATE) \{
00109     ang += calculate_encoder_angle();
00110     set_side_speed(LEFT, MAX_SPEED);
00111     set_side_speed(RIGHT, MIN_SPEED);
00112   \}
00113   set_side_speed(BOTH, 0);
00114 
00115   counts\_drive = 0;
00116 
00117   \textcolor{keywordflow}{while} (counts\_drive < MOBILE_GOAL_DISTANCE + ZONE_DISTANCE) \{
00118     set_side_speed(BOTH, 127);
00119     \textcolor{comment}{// Restablish the distance traveled}
00120     imeGet(MID_LEFT_DRIVE, &counts\_drive\_left);
00121     imeGet(MID_RIGHT_DRIVE, &counts\_drive\_right);
00122     counts\_drive = counts\_drive\_left + counts\_drive\_right;
00123     counts\_drive /= 2;
00124   \}
00125 
00126   lower_intake();
00127   delay(300);
00128   set_intake_motor(0);
00129 
00130   set_side_speed(BOTH, MIN_SPEED);
00131   delay(1000);
00132   set_side_speed(BOTH, 0);
00133 
00134   deinitslew();
00135 \}
\end{DoxyCode}
