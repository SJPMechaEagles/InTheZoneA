\subsection{list.\+c}
\label{a00110_source}\index{src/list.\+c@{src/list.\+c}}

\begin{DoxyCode}
00001 
00002 \textcolor{comment}{//}
00003 \textcolor{comment}{// list.c}
00004 \textcolor{comment}{//}
00005 \textcolor{comment}{// Copyright (c) 2010 TJ Holowaychuk <tj@vision-media.ca>}
00006 \textcolor{comment}{//}
00007 
00008 \textcolor{preprocessor}{#include "list.h"}
00009 
00010 \textcolor{comment}{/*}
00011 \textcolor{comment}{ * Allocate a new list\_t. NULL on failure.}
00012 \textcolor{comment}{ */}
00013 
00014 list_t *list_new() \{
00015   list_t *\textcolor{keyword}{self};
00016   \textcolor{keywordflow}{if} (!(\textcolor{keyword}{self} = LIST_MALLOC(\textcolor{keyword}{sizeof}(list_t))))
00017     \textcolor{keywordflow}{return} NULL;
00018   \textcolor{keyword}{self}->head = NULL;
00019   \textcolor{keyword}{self}->tail = NULL;
00020   \textcolor{keyword}{self}->free = NULL;
00021   \textcolor{keyword}{self}->match = NULL;
00022   \textcolor{keyword}{self}->len = 0;
00023   \textcolor{keywordflow}{return} \textcolor{keyword}{self};
00024 \}
00025 
00026 \textcolor{comment}{/*}
00027 \textcolor{comment}{ * Free the list.}
00028 \textcolor{comment}{ */}
00029 
00030 \textcolor{keywordtype}{void} list_destroy(list_t *\textcolor{keyword}{self}) \{
00031   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len = \textcolor{keyword}{self}->len;
00032   list_node_t *next;
00033   list_node_t *curr = \textcolor{keyword}{self}->head;
00034 
00035   \textcolor{keywordflow}{while} (len--) \{
00036     next = curr->next;
00037     \textcolor{keywordflow}{if} (self->free)
00038       \textcolor{keyword}{self}->free(curr->val);
00039     LIST_FREE(curr);
00040     curr = next;
00041   \}
00042 
00043   LIST_FREE(\textcolor{keyword}{self});
00044 \}
00045 
00046 \textcolor{comment}{/*}
00047 \textcolor{comment}{ * Append the given node to the list}
00048 \textcolor{comment}{ * and return the node, NULL on failure.}
00049 \textcolor{comment}{ */}
00050 
00051 list_node_t *list_rpush(list_t *\textcolor{keyword}{self}, list_node_t *node) \{
00052   \textcolor{keywordflow}{if} (!node)
00053     \textcolor{keywordflow}{return} NULL;
00054 
00055   \textcolor{keywordflow}{if} (self->len) \{
00056     node->prev = \textcolor{keyword}{self}->tail;
00057     node->next = NULL;
00058     \textcolor{keyword}{self}->tail->next = node;
00059     \textcolor{keyword}{self}->tail = node;
00060   \} \textcolor{keywordflow}{else} \{
00061     \textcolor{keyword}{self}->head = \textcolor{keyword}{self}->tail = node;
00062     node->prev = node->next = NULL;
00063   \}
00064 
00065   ++\textcolor{keyword}{self}->len;
00066   \textcolor{keywordflow}{return} node;
00067 \}
00068 
00069 \textcolor{comment}{/*}
00070 \textcolor{comment}{ * Return / detach the last node in the list, or NULL.}
00071 \textcolor{comment}{ */}
00072 
00073 list_node_t *list_rpop(list_t *\textcolor{keyword}{self}) \{
00074   \textcolor{keywordflow}{if} (!self->len)
00075     \textcolor{keywordflow}{return} NULL;
00076 
00077   list_node_t *node = \textcolor{keyword}{self}->tail;
00078 
00079   \textcolor{keywordflow}{if} (--self->len) \{
00080     (\textcolor{keyword}{self}->tail = node->prev)->next = NULL;
00081   \} \textcolor{keywordflow}{else} \{
00082     \textcolor{keyword}{self}->tail = \textcolor{keyword}{self}->head = NULL;
00083   \}
00084 
00085   node->next = node->prev = NULL;
00086   \textcolor{keywordflow}{return} node;
00087 \}
00088 
00089 \textcolor{comment}{/*}
00090 \textcolor{comment}{ * Return / detach the first node in the list, or NULL.}
00091 \textcolor{comment}{ */}
00092 
00093 list_node_t *list_lpop(list_t *\textcolor{keyword}{self}) \{
00094   \textcolor{keywordflow}{if} (!self->len)
00095     \textcolor{keywordflow}{return} NULL;
00096 
00097   list_node_t *node = \textcolor{keyword}{self}->head;
00098 
00099   \textcolor{keywordflow}{if} (--self->len) \{
00100     (\textcolor{keyword}{self}->head = node->next)->prev = NULL;
00101   \} \textcolor{keywordflow}{else} \{
00102     \textcolor{keyword}{self}->head = \textcolor{keyword}{self}->tail = NULL;
00103   \}
00104 
00105   node->next = node->prev = NULL;
00106   \textcolor{keywordflow}{return} node;
00107 \}
00108 
00109 \textcolor{comment}{/*}
00110 \textcolor{comment}{ * Prepend the given node to the list}
00111 \textcolor{comment}{ * and return the node, NULL on failure.}
00112 \textcolor{comment}{ */}
00113 
00114 list_node_t *list_lpush(list_t *\textcolor{keyword}{self}, list_node_t *node) \{
00115   \textcolor{keywordflow}{if} (!node)
00116     \textcolor{keywordflow}{return} NULL;
00117 
00118   \textcolor{keywordflow}{if} (self->len) \{
00119     node->next = \textcolor{keyword}{self}->head;
00120     node->prev = NULL;
00121     \textcolor{keyword}{self}->head->prev = node;
00122     \textcolor{keyword}{self}->head = node;
00123   \} \textcolor{keywordflow}{else} \{
00124     \textcolor{keyword}{self}->head = \textcolor{keyword}{self}->tail = node;
00125     node->prev = node->next = NULL;
00126   \}
00127 
00128   ++\textcolor{keyword}{self}->len;
00129   \textcolor{keywordflow}{return} node;
00130 \}
00131 
00132 \textcolor{comment}{/*}
00133 \textcolor{comment}{ * Return the node associated to val or NULL.}
00134 \textcolor{comment}{ */}
00135 
00136 list_node_t *list_find(list_t *\textcolor{keyword}{self}, \textcolor{keywordtype}{void} *val) \{
00137   list_iterator_t *it = list_iterator_new(\textcolor{keyword}{self}, LIST_HEAD);
00138   list_node_t *node;
00139 
00140   \textcolor{keywordflow}{while} ((node = list_iterator_next(it))) \{
00141     \textcolor{keywordflow}{if} (self->match) \{
00142       \textcolor{keywordflow}{if} (self->match(val, node->val)) \{
00143         list_iterator_destroy(it);
00144         \textcolor{keywordflow}{return} node;
00145       \}
00146     \} \textcolor{keywordflow}{else} \{
00147       \textcolor{keywordflow}{if} (val == node->val) \{
00148         list_iterator_destroy(it);
00149         \textcolor{keywordflow}{return} node;
00150       \}
00151     \}
00152   \}
00153 
00154   list_iterator_destroy(it);
00155   \textcolor{keywordflow}{return} NULL;
00156 \}
00157 
00158 \textcolor{comment}{/*}
00159 \textcolor{comment}{ * Return the node at the given index or NULL.}
00160 \textcolor{comment}{ */}
00161 
00162 list_node_t *list_at(list_t *\textcolor{keyword}{self}, \textcolor{keywordtype}{int} index) \{
00163   list_direction_t direction = LIST_HEAD;
00164 
00165   \textcolor{keywordflow}{if} (index < 0) \{
00166     direction = LIST_TAIL;
00167     index = ~index;
00168   \}
00169 
00170   \textcolor{keywordflow}{if} ((\textcolor{keywordtype}{unsigned})index < self->len) \{
00171     list_iterator_t *it = list_iterator_new(\textcolor{keyword}{self}, direction);
00172     list_node_t *node = list_iterator_next(it);
00173     \textcolor{keywordflow}{while} (index--)
00174       node = list_iterator_next(it);
00175     list_iterator_destroy(it);
00176     \textcolor{keywordflow}{return} node;
00177   \}
00178 
00179   \textcolor{keywordflow}{return} NULL;
00180 \}
00181 
00182 \textcolor{comment}{/*}
00183 \textcolor{comment}{ * Remove the given node from the list, freeing it and it's value.}
00184 \textcolor{comment}{ */}
00185 
00186 \textcolor{keywordtype}{void} list_remove(list_t *\textcolor{keyword}{self}, list_node_t *node) \{
00187   node->prev ? (node->prev->next = node->next) : (self->head = node->next);
00188 
00189   node->next ? (node->next->prev = node->prev) : (self->tail = node->prev);
00190 
00191   \textcolor{keywordflow}{if} (self->free)
00192     \textcolor{keyword}{self}->free(node->val);
00193 
00194   LIST_FREE(node);
00195   --\textcolor{keyword}{self}->len;
00196 \}
\end{DoxyCode}
