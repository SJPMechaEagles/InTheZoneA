.TH "src/matrix.c" 3 "Tue Nov 28 2017" "Version 1.1.4" "Vex Team 9228A" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/matrix.c
.SH SYNOPSIS
.br
.PP
\fC#include 'matrix\&.h'\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBassert\fP (int assertion, const char *message)"
.br
.RI "Asserts a condition is true\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBcopyMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "Copies a matrix\&. This function uses scaleMatrix, because scaling matrix by 1 is the same as a copy\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBcovarianceMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "returns the covariance of the matrix "
.ti -1c
.RI "\fBmatrix\fP * \fBdotDiagonalMatrix\fP (\fBmatrix\fP *a, \fBmatrix\fP *b)"
.br
.RI "performs a diagonial matrix dot product\&. Given a two matrices (or the same matrix twice) with identical widths and heights, this method returns a 1 by a->height matrix of the cross product of each matrix along the diagonal\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBdotProductMatrix\fP (\fBmatrix\fP *a, \fBmatrix\fP *b)"
.br
.RI "returns the matrix dot product\&. Given a two matrices (or the same matrix twice) with identical widths and different heights, this method returns a a->height by b->height matrix of the cross product of each matrix\&. "
.ti -1c
.RI "void \fBfreeMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "Frees the resources of a matrix\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBidentityMatrix\fP (int n)"
.br
.RI "Returns an identity matrix of size n by n\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBmakeMatrix\fP (int width, int height)"
.br
.RI "Makes a matrix with a width and height parameters\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBmeanMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "Given an 'm rows by n columns' matrix, return a matrix where each element represents the mean of that full column\&.  the matrix\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBmultiplyMatrix\fP (\fBmatrix\fP *a, \fBmatrix\fP *b)"
.br
.RI "Given a two matrices, returns the multiplication of the two\&. "
.ti -1c
.RI "void \fBprintMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "Prints a matrix\&. "
.ti -1c
.RI "void \fBrowSwap\fP (\fBmatrix\fP *a, int p, int q)"
.br
.RI "swaps the rows of a matrix\&. This method changes the input matrix\&. Given a matrix, this algorithm will swap rows p and q, provided that p and q are less than or equal to the height of matrix A and p and q are different values\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBscaleMatrix\fP (\fBmatrix\fP *m, double value)"
.br
.RI "scales a matrix\&. "
.ti -1c
.RI "double \fBtraceMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "Given an 'm rows by n columns' matrix returns the sum\&. "
.ti -1c
.RI "\fBmatrix\fP * \fBtransposeMatrix\fP (\fBmatrix\fP *m)"
.br
.RI "returns the transpose matrix\&. "
.in -1c
.SH "Function Documentation"
.PP 
.SS "void assert (int assertion, const char * message)"

.PP
Asserts a condition is true\&. If the assertion is non-zero (i\&.e\&. true), then it returns\&. If the assertion is zero (i\&.e\&. false), then it display the string and aborts the program\&. This is ment to act like Python's assert keyword\&. 
.PP
Definition at line 14 of file matrix\&.c\&.
.PP
References fprintf()\&.
.PP
Referenced by covarianceMatrix(), dotDiagonalMatrix(), dotProductMatrix(), identityMatrix(), makeMatrix(), meanMatrix(), multiplyMatrix(), and rowSwap()\&.
.PP
.nf
14                                                 {
15     if (assertion == 0) {
16         fprintf(stderr, "%s\n", message);
17         exit(1);
18     }
19 }
.fi
.SS "\fBmatrix\fP* copyMatrix (\fBmatrix\fP * m)"

.PP
Copies a matrix\&. This function uses scaleMatrix, because scaling matrix by 1 is the same as a copy\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP a pointer to the matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
a copied matrix 
.RE
.PP

.PP
Definition at line 52 of file matrix\&.c\&.
.PP
References scaleMatrix()\&.
.PP
.nf
52                               {
53     return scaleMatrix(m, 1);
54 }
.fi
.SS "\fBmatrix\fP* covarianceMatrix (\fBmatrix\fP * m)"

.PP
returns the covariance of the matrix 
.PP
\fBParameters:\fP
.RS 4
\fIthe\fP matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
a matrix with n row and n columns, where each element represents covariance of 2 columns\&. 
.RE
.PP

.PP
Definition at line 168 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, freeMatrix(), _matrix::height, makeMatrix(), meanMatrix(), and _matrix::width\&.
.PP
.nf
168                                     {
169     int i, j, k = 0;
170     matrix* out;
171     matrix* mean;
172     double* ptrA;
173     double* ptrB;
174     double* ptrOut;
175 
176     assert(m->height > 1, "Height of matrix cannot be zero or one\&.");
177 
178     mean = meanMatrix(m);
179     out = makeMatrix(m->width, m->width);
180     ptrOut = out->data;
181 
182     for (i = 0; i < m->width; i++) {
183         for (j = 0; j < m->width; j++) {
184              ptrA = &m->data[i];
185              ptrB = &m->data[j];
186              *ptrOut = 0\&.0;
187              for (k = 0; k < m->height; k++) {
188                  *ptrOut += (*ptrA - mean->data[i]) * (*ptrB - mean->data[j]);
189                  ptrA += m->width;
190                  ptrB += m->width;
191              }
192              *ptrOut /= m->height - 1;
193              ptrOut++;
194         }
195     }
196 
197     freeMatrix(mean);
198     return out;
199 }
.fi
.SS "\fBmatrix\fP* dotDiagonalMatrix (\fBmatrix\fP * a, \fBmatrix\fP * b)"

.PP
performs a diagonial matrix dot product\&. Given a two matrices (or the same matrix twice) with identical widths and heights, this method returns a 1 by a->height matrix of the cross product of each matrix along the diagonal\&. Dot product is essentially the sum-of-squares of two vectors\&.
.PP
If the second paramter is NULL, it is assumed that we are performing a cross product with itself\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP the first matrix 
.br
\fIb\fP the second matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
the matrix result 
.RE
.PP

.PP
Definition at line 385 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, _matrix::height, makeMatrix(), and _matrix::width\&.
.PP
.nf
385                                                 {
386     matrix* out;
387     double* ptrOut;
388     double* ptrA;
389     double* ptrB;
390     int i, j;
391 
392     if (b != NULL) {
393         assert(a->width == b->width && a->height == b->height, "Matrices must be of the same dimensionality\&.");
394     }
395 
396     // Are we computing the sum of squares of the same matrix?
397     if (a == b || b == NULL) {
398         b = a; // May not appear safe, but we can do this without risk of losing b\&.
399     }
400 
401     out = makeMatrix(1, a->height);
402     ptrOut = out->data;
403     ptrA = a->data;
404     ptrB = b->data;
405 
406     for (i = 0; i < a->height; i++) {
407         *ptrOut = 0;
408         for (j = 0; j < a->width; j++) {
409             *ptrOut += *ptrA * *ptrB;
410             ptrA++;
411             ptrB++;
412         }
413         ptrOut++;
414     }
415 
416     return out;
417 }
.fi
.SS "\fBmatrix\fP* dotProductMatrix (\fBmatrix\fP * a, \fBmatrix\fP * b)"

.PP
returns the matrix dot product\&. Given a two matrices (or the same matrix twice) with identical widths and different heights, this method returns a a->height by b->height matrix of the cross product of each matrix\&. Dot product is essentially the sum-of-squares of two vectors\&.
.PP
Also, if the second paramter is NULL, it is assumed that we are performing a cross product with itself\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP the first matrix 
.br
\fIthe\fP second matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
the result of the dot product 
.RE
.PP

.PP
Definition at line 333 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, _matrix::height, makeMatrix(), and _matrix::width\&.
.PP
.nf
333                                                {
334     matrix* out;
335     double* ptrOut;
336     double* ptrA;
337     double* ptrB;
338     int i, j, k;
339 
340     if (b != NULL) {
341         assert(a->width == b->width, "Matrices must be of the same dimensionality\&.");
342     }
343 
344     // Are we computing the sum of squares of the same matrix?
345     if (a == b || b == NULL) {
346         b = a; // May not appear safe, but we can do this without risk of losing b\&.
347     }
348 
349     out = makeMatrix(b->height, a->height);
350     ptrOut = out->data;
351 
352     for (i = 0; i < a->height; i++) {
353         ptrB = b->data;
354 
355         for (j = 0; j < b->height; j++) {
356             ptrA = &a->data[ i * a->width ];
357 
358             *ptrOut = 0;
359             for (k = 0; k < a->width; k++) {
360                 *ptrOut += *ptrA * *ptrB;
361                 ptrA++;
362                 ptrB++;
363             }
364             ptrOut++;
365         }
366     }
367 
368     return out;
369 }
.fi
.SS "void freeMatrix (\fBmatrix\fP * m)"

.PP
Frees the resources of a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthe\fP matrix to free 
.RE
.PP

.PP
Definition at line 60 of file matrix\&.c\&.
.PP
References _matrix::data\&.
.PP
Referenced by covarianceMatrix()\&.
.PP
.nf
60                            {
61     if (m != NULL) {
62         if (m->data != NULL) {
63             free(m->data);
64             m->data = NULL;
65         }
66         free(m);
67     }
68     return;
69 }
.fi
.SS "\fBmatrix\fP* identityMatrix (int n)"

.PP
Returns an identity matrix of size n by n\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP the input matrix\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the identity matrix parameter\&. 
.RE
.PP

.PP
Definition at line 94 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, and makeMatrix()\&.
.PP
.nf
94                               {
95     int i;
96     matrix *out;
97     double* ptr;
98 
99     assert(n > 0, "Identity matrix must have value greater than zero\&.");
100 
101     out = makeMatrix(n, n);
102     ptr = out->data;
103     for (i = 0; i < n; i++) {
104         *ptr = 1\&.0;
105         ptr += n + 1;
106     }
107 
108     return out;
109 }
.fi
.SS "\fBmatrix\fP* makeMatrix (int width, int height)"

.PP
Makes a matrix with a width and height parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP The width of the matrix 
.br
\fIheight\fP the height of the matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
the new matrix 
.RE
.PP

.PP
Definition at line 27 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, _matrix::height, and _matrix::width\&.
.PP
Referenced by covarianceMatrix(), dotDiagonalMatrix(), dotProductMatrix(), identityMatrix(), init_localization(), meanMatrix(), multiplyMatrix(), scaleMatrix(), and transposeMatrix()\&.
.PP
.nf
27                                           {
28     matrix* out;
29     assert(width > 0 && height > 0, "New matrix must be at least a 1 by 1");
30     out = (matrix*) malloc(sizeof(matrix));
31 
32     assert(out != NULL, "Out of memory\&.");
33 
34     out->width = width;
35     out->height = height;
36     out->data = (double*) malloc(sizeof(double) * width * height);
37 
38     assert(out->data != NULL, "Out of memory\&.");
39 
40     memset(out->data, 0\&.0, width * height * sizeof(double));
41 
42     return out;
43 }
.fi
.SS "\fBmatrix\fP* meanMatrix (\fBmatrix\fP * m)"

.PP
Given an 'm rows by n columns' matrix, return a matrix where each element represents the mean of that full column\&.  the matrix\&. 
.PP
\fBReturns:\fP
.RS 4
matrix with 1 row and n columns each element represents the mean of that full column\&. 
.RE
.PP

.PP
Definition at line 142 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, _matrix::height, makeMatrix(), and _matrix::width\&.
.PP
Referenced by covarianceMatrix()\&.
.PP
.nf
142                               {
143     int i, j;
144     matrix* out;
145 
146     assert(m->height > 0, "Height of matrix cannot be zero\&.");
147 
148     out = makeMatrix(m->width, 1);
149 
150     for (i = 0; i < m->width; i++) {
151         double* ptr;
152         out->data[i] = 0\&.0;
153         ptr = &m->data[i];
154         for (j = 0; j < m->height; j++) {
155             out->data[i] += *ptr;
156             ptr += out->width;
157         }
158         out->data[i] /= (double) m->height;
159     }
160     return out;
161 }
.fi
.SS "\fBmatrix\fP* multiplyMatrix (\fBmatrix\fP * a, \fBmatrix\fP * b)"

.PP
Given a two matrices, returns the multiplication of the two\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP the first matrix 
.br
\fIb\fP the seconf matrix return the result of the multiplication 
.RE
.PP

.PP
Definition at line 230 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, _matrix::height, makeMatrix(), and _matrix::width\&.
.PP
.nf
230                                              {
231     int i, j, k;
232     matrix* out;
233     double* ptrOut;
234     double* ptrA;
235     double* ptrB;
236 
237     assert(a->width == b->height, "Matrices have incorrect dimensions\&. a->width != b->height");
238 
239     out = makeMatrix(b->width, a->height);
240     ptrOut = out->data;
241 
242     for (i = 0; i < a->height; i++) {
243 
244         for (j = 0; j < b->width; j++) {
245             ptrA = &a->data[ i * a->width ];
246             ptrB = &b->data[ j ];
247 
248             *ptrOut = 0;
249             for (k = 0; k < a->width; k++) {
250                 *ptrOut += *ptrA * *ptrB;
251                 ptrA++;
252                 ptrB += b->width;
253             }
254             ptrOut++;
255         }
256     }
257 
258     return out;
259 }
.fi
.SS "void printMatrix (\fBmatrix\fP * m)"

.PP
Prints a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthe\fP matrix 
.RE
.PP

.PP
Definition at line 75 of file matrix\&.c\&.
.PP
References _matrix::data, _matrix::height, printf(), and _matrix::width\&.
.PP
.nf
75                             {
76     int i, j;
77     double* ptr = m->data;
78     printf("%d %d\n", m->width, m->height);
79     for (i = 0; i < m->height; i++) {
80         for (j = 0; j < m->width; j++) {
81             printf(" %9\&.6f", *(ptr++));
82         }
83         printf("\n");
84     }
85     return;
86 }
.fi
.SS "void rowSwap (\fBmatrix\fP * a, int p, int q)"

.PP
swaps the rows of a matrix\&. This method changes the input matrix\&. Given a matrix, this algorithm will swap rows p and q, provided that p and q are less than or equal to the height of matrix A and p and q are different values\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthe\fP matrix to swap\&. This method changes the input matrix\&. 
.br
\fIthe\fP first row 
.br
\fIthe\fP second row 
.RE
.PP

.PP
Definition at line 290 of file matrix\&.c\&.
.PP
References assert(), _matrix::data, _matrix::height, and _matrix::width\&.
.PP
.nf
290                                       {
291     int i;
292     double temp;
293     double* pRow;
294     double* qRow;
295 
296     assert(a->height > 2, "Matrix must have at least two rows to swap\&.");
297     assert(p < a->height && q < a->height, "Values p and q must be less than the height of the matrix\&.");
298 
299     // If p and q are equal, do nothing\&.
300     if (p == q) {
301         return;
302     }
303 
304     pRow = a->data + (p * a->width);
305     qRow = a->data + (q * a->width);
306 
307     // Swap!
308     for (i = 0; i < a->width; i++) {
309         temp = *pRow;
310         *pRow = *qRow;
311         *qRow = temp;
312         pRow++;
313         qRow++;
314     }
315 
316     return;
317 }
.fi
.SS "\fBmatrix\fP* scaleMatrix (\fBmatrix\fP * m, double value)"

.PP
scales a matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIm\fP the matrix to scale 
.br
\fIthe\fP value to scale by 
.RE
.PP
\fBReturns:\fP
.RS 4
a new matrix where each element in the input matrix is multiplied by the scalar value 
.RE
.PP

.PP
Definition at line 268 of file matrix\&.c\&.
.PP
References _matrix::data, _matrix::height, makeMatrix(), and _matrix::width\&.
.PP
Referenced by copyMatrix()\&.
.PP
.nf
268                                              {
269     int i, elements = m->width * m->height;
270     matrix* out = makeMatrix(m->width, m->height);
271     double* ptrM = m->data;
272     double* ptrOut = out->data;
273 
274     for (i = 0; i < elements; i++) {
275         *(ptrOut++) = *(ptrM++) * value;
276     }
277 
278     return out;
279 }
.fi
.SS "double traceMatrix (\fBmatrix\fP * m)"

.PP
Given an 'm rows by n columns' matrix returns the sum\&. Given an 'm rows by n columns' matrix\&.
.PP
\fBReturns:\fP
.RS 4
the sum of the elements along the diagonal\&. 
.RE
.PP

.PP
Definition at line 116 of file matrix\&.c\&.
.PP
References _matrix::data, _matrix::height, and _matrix::width\&.
.PP
.nf
116                               {
117     int i;
118     int size;
119     double* ptr = m->data;
120     double sum = 0\&.0;
121 
122     if (m->height < m->width) {
123         size = m->height;
124     }
125     else {
126         size = m->width;
127     }
128 
129     for (i = 0; i < size; i++) {
130         sum += *ptr;
131         ptr += m->width + 1;
132     }
133 
134     return sum;
135 }
.fi
.SS "\fBmatrix\fP* transposeMatrix (\fBmatrix\fP * m)"

.PP
returns the transpose matrix\&. 
.PP
\fBParameters:\fP
.RS 4
\fIthe\fP matrix to transpose\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
the transposed matrix\&. 
.RE
.PP

.PP
Definition at line 206 of file matrix\&.c\&.
.PP
References _matrix::data, _matrix::height, makeMatrix(), and _matrix::width\&.
.PP
.nf
206                                    {
207     matrix* out = makeMatrix(m->height, m->width);
208     double* ptrM = m->data;
209     int i, j;
210 
211     for (i = 0; i < m->height; i++) {
212         double* ptrOut;
213         ptrOut = &out->data[i];
214         for (j = 0; j < m->width; j++) {
215             *ptrOut = *ptrM;
216             ptrM++;
217             ptrOut += out->width;
218         }
219     }
220 
221     return out;
222 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Vex Team 9228A from the source code\&.
