.TH "src/menu.c" 3 "Tue Nov 28 2017" "Version 1.1.4" "Vex Team 9228A" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/menu.c
.SH SYNOPSIS
.br
.PP
\fC#include 'menu\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBcalculate_current_display\fP (char *rtn, \fBmenu_t\fP *menu)"
.br
.ti -1c
.RI "static \fBmenu_t\fP * \fBcreate_menu\fP (enum \fBmenu_type\fP type, const char *prompt)"
.br
.ti -1c
.RI "void \fBdenint_menu\fP (\fBmenu_t\fP *menu)"
.br
.RI "Destroys a menu \fI Menu must be freed or will cause memory leak \fI \fP\fP"
.ti -1c
.RI "int \fBdisplay_menu\fP (\fBmenu_t\fP *menu)"
.br
.RI "Displays a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak! \fI Will exit if robot is enabled\&. This prevents menu from locking up system in even of a reset\&. \fP\fP"
.ti -1c
.RI "\fBmenu_t\fP * \fBinit_menu_float\fP (enum \fBmenu_type\fP type, float \fBmin\fP, float \fBmax\fP, float step, const char *prompt)"
.br
.RI "Creates a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak! \fI \fP\fP"
.ti -1c
.RI "\fBmenu_t\fP * \fBinit_menu_int\fP (enum \fBmenu_type\fP type, int \fBmin\fP, int \fBmax\fP, int step, const char *prompt)"
.br
.RI "Creates a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak \fI \fP\fP"
.ti -1c
.RI "\fBmenu_t\fP * \fBinit_menu_var\fP (enum \fBmenu_type\fP type, unsigned int nums, const char *prompt, char *options,\&.\&.\&.)"
.br
.RI "Creates a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak \fI \fP\fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "static void calculate_current_display (char * rtn, \fBmenu_t\fP * menu)\fC [static]\fP"

.PP
Definition at line 56 of file menu\&.c\&.
.PP
References menu_t::current, FLOAT_TYPE, ftoa_bad(), INT_TYPE, itoa_bad(), menu_t::length, max(), menu_t::max, menu_t::max_f, min(), menu_t::min, menu_t::min_f, menu_t::options, menu_t::step, menu_t::step_f, STRING_TYPE, and menu_t::type\&.
.PP
Referenced by display_menu()\&.
.PP
.nf
56                                                                {
57   if(menu->type == STRING_TYPE){
58     //Ignore warning
59     rtn = (menu->options[menu->current % (menu->length)]);
60   }
61   if(menu->type == INT_TYPE) {
62     int step = (menu->step);
63     int min = (menu->min);
64     int max = (menu->max);
65     int value = menu->current * step;
66     value = value < min ? min : value;
67     value = value > max ? max : value;
68     itoa_bad(value, rtn, 4);
69   }
70   if(menu->type == FLOAT_TYPE) {
71     float step = (menu->step_f);
72     float min = (menu->min_f);
73     float max = (menu->max_f);
74     float value = menu->current * step;
75     value = value < min ? min : value;
76     value = value > max ? max : value;
77 
78     ftoa_bad(value, rtn, 5);
79   }
80 }
.fi
.SS "static \fBmenu_t\fP * create_menu (enum \fBmenu_type\fP type, const char * prompt)\fC [static]\fP"

.PP
Definition at line 6 of file menu\&.c\&.
.PP
References error(), menu_t::max, menu_t::max_f, menu_t::min, menu_t::min_f, menu_t::prompt, menu_t::step, menu_t::step_f, and menu_t::type\&.
.PP
Referenced by init_menu_float(), init_menu_int(), and init_menu_var()\&.
.PP
.nf
6                                                                     {
7   menu_t* menu = (menu_t*) malloc(sizeof(menu_t));
8   if (!menu) {
9     error("Menu Malloc");
10   }
11   menu->type = type;
12   // Add one for null terminator
13   size_t strlength = strlen(prompt) + 1;
14   menu->prompt = (char*) malloc(strlength * sizeof(char));
15   memcpy(menu->prompt, prompt, strlength);
16   menu->max = INT_MAX;
17   menu->min = INT_MIN;
18   menu->step = 1;
19   menu->min_f = FLT_MIN;
20   menu->max_f = FLT_MAX;
21   menu->step_f = 1;
22 
23   return menu;
24 }
.fi
.SS "void denint_menu (\fBmenu_t\fP * menu)"

.PP
Destroys a menu \fI Menu must be freed or will cause memory leak \fI \fP\fP
.PP
\fBParameters:\fP
.RS 4
\fImenu\fP the menu to free 
.RE
.PP
\fBSee also:\fP
.RS 4
menu 
.RE
.PP
\fBAuthor:\fP
.RS 4
Chris Jerrett 
.RE
.PP
\fBDate:\fP
.RS 4
9/8/17 
.RE
.PP

.PP
Definition at line 101 of file menu\&.c\&.
.PP
References menu_t::options, and menu_t::prompt\&.
.PP
.nf
101                               {
102   free(menu->prompt);
103   if(menu->options != NULL) free(menu->options);
104   free(menu);
105 }
.fi
.SS "int display_menu (\fBmenu_t\fP * menu)"

.PP
Displays a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak! \fI Will exit if robot is enabled\&. This prevents menu from locking up system in even of a reset\&. \fP\fP
.PP
\fBParameters:\fP
.RS 4
\fImenu\fP the menu to display 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBmenu_type\fP 
.RE
.PP
\fBAuthor:\fP
.RS 4
Chris Jerrett 
.RE
.PP
\fBDate:\fP
.RS 4
9/8/17 
.RE
.PP

.PP
Definition at line 83 of file menu\&.c\&.
.PP
References calculate_current_display(), menu_t::current, delay(), isEnabled(), lcd_get_pressed_buttons(), lcd_print(), PRESSED, menu_t::prompt, RELEASED, and TOP_ROW\&.
.PP
.nf
83                               {
84   lcd_print(TOP_ROW, menu->prompt);
85   //Will exit if teleop or autonomous begin\&. This is extremely important if robot disconnects or resets\&.
86   while(lcd_get_pressed_buttons()\&.middle == RELEASED && !isEnabled()) {
87     char val[16];
88     calculate_current_display(val, menu);
89 
90     if(lcd_get_pressed_buttons()\&.right == PRESSED) {
91       menu->current += 1;
92     }
93     if(lcd_get_pressed_buttons()\&.left == PRESSED) {
94       menu->current -= 1;
95     }
96     delay(500);
97   }
98   return menu->current;
99 }
.fi
.SS "\fBmenu_t\fP* init_menu_float (enum \fBmenu_type\fP type, float min, float max, float step, const char * prompt)"

.PP
Creates a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak! \fI \fP\fP
.PP
\fBParameters:\fP
.RS 4
\fItype\fP the type of menu 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBmenu_type\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fImin\fP the minimum value 
.br
\fImax\fP the maximum value 
.br
\fIstep\fP the step value 
.br
\fIprompt\fP the prompt to display to user 
.RE
.PP
\fBAuthor:\fP
.RS 4
Chris Jerrett 
.RE
.PP
\fBDate:\fP
.RS 4
9/8/17 
.RE
.PP

.PP
Definition at line 48 of file menu\&.c\&.
.PP
References create_menu(), max(), menu_t::max_f, min(), menu_t::min_f, and menu_t::step_f\&.
.PP
.nf
48                                                                                                   {
49   menu_t* menu = create_menu(type, prompt);
50   menu->min_f = min;
51   menu->max_f = max;
52   menu->step_f = step;
53   return menu;
54 }
.fi
.SS "\fBmenu_t\fP* init_menu_int (enum \fBmenu_type\fP type, int min, int max, int step, const char * prompt)"

.PP
Creates a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak \fI \fP\fP
.PP
\fBParameters:\fP
.RS 4
\fItype\fP the type of menu 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBmenu_type\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fImin\fP the minimum value 
.br
\fImax\fP the maximum value 
.br
\fIstep\fP the step value 
.br
\fIprompt\fP the prompt to display to user 
.RE
.PP
\fBAuthor:\fP
.RS 4
Chris Jerrett 
.RE
.PP
\fBDate:\fP
.RS 4
9/8/17 
.RE
.PP

.PP
Definition at line 40 of file menu\&.c\&.
.PP
References create_menu(), max(), menu_t::max, min(), menu_t::min, and menu_t::step\&.
.PP
.nf
40                                                                                           {
41   menu_t* menu = create_menu(type, prompt);
42   menu->min = min;
43   menu->max = max;
44   menu->step = step;
45   return menu;
46 }
.fi
.SS "\fBmenu_t\fP* init_menu_var (enum \fBmenu_type\fP type, unsigned int nums, const char * prompt, char * options,  \&.\&.\&.)"

.PP
Creates a menu context, but does not display\&. \fI Menu must be freed or will cause memory leak \fI \fP\fP
.PP
\fBParameters:\fP
.RS 4
\fItype\fP the type of menu 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBmenu_type\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fInums\fP the number of elements passed to function 
.br
\fIprompt\fP the prompt to display to user 
.br
\fIoptions\fP the options to display for user 
.RE
.PP
\fBAuthor:\fP
.RS 4
Chris Jerrett 
.RE
.PP
\fBDate:\fP
.RS 4
9/8/17 
.RE
.PP

.PP
Definition at line 26 of file menu\&.c\&.
.PP
References create_menu(), menu_t::length, and menu_t::options\&.
.PP
.nf
26                                                                                                     {
27   menu_t* menu = create_menu(type, prompt);
28   va_list values;
29   char **options_array = (char**)calloc(sizeof(char*), nums);
30   va_start(values, options);
31   for(unsigned int i = 0; i < nums; i++){
32     options_array[i] = va_arg(values, char*);
33   }
34   va_end(values);
35   menu->options = options_array;
36   menu->length = nums;
37   return menu;
38 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for Vex Team 9228A from the source code\&.
