.TH "src/localization.c" 3 "Tue Nov 28 2017" "Version 1.1.4" "Vex Team 9228A" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/localization.c
.SH SYNOPSIS
.br
.PP
\fC#include 'localization\&.h'\fP
.br
\fC#include <inttypes\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBaccelerometer_odometry\fP"
.br
.ti -1c
.RI "struct \fBencoder_odemtry\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static struct \fBaccelerometer_odometry\fP \fBcalculate_accelerometer_odemetry\fP ()"
.br
.ti -1c
.RI "static double \fBcalculate_angle\fP ()"
.br
.ti -1c
.RI "static double \fBcalculate_gryo_anglular_velocity\fP ()"
.br
.ti -1c
.RI "struct \fBlocation\fP \fBget_position\fP ()"
.br
.RI "Gets the current posituion of the robot\&. "
.ti -1c
.RI "bool \fBinit_localization\fP (const unsigned char gyro1, unsigned short multiplier, int start_x, int start_y, int start_theta)"
.br
.RI "Starts the localization process\&. "
.ti -1c
.RI "static double \fBintegrate_gyro_w\fP (int new_w)"
.br
.ti -1c
.RI "void \fBupdate_position\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBGyro\fP \fBg1\fP"
.br
.ti -1c
.RI "static int \fBlast_call\fP = 0"
.br
.ti -1c
.RI "static \fBTaskHandle\fP \fBlocalization_task\fP"
.br
.ti -1c
.RI "\fBmatrix\fP * \fBstate_matrix\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "static struct \fBaccelerometer_odometry\fP calculate_accelerometer_odemetry ()\fC [static]\fP"

.PP
Definition at line 49 of file localization\&.c\&.
.PP
References analogReadCalibratedHR(), last_call, millis(), and printf()\&.
.PP
Referenced by update_position()\&.
.PP
.nf
49                                                                         {
50   static double vel_acumm_x = 0;
51   static double vel_acumm_y = 0;
52 
53   int32_t accel_x_rel = (int32_t) analogReadCalibratedHR(2);
54   int32_t accel_y_rel = (int32_t) analogReadCalibratedHR(3);
55 
56   //Ignore atom format string errors
57   printf("x: %+" PRId32 " y: %+" PRId32 "\n", accel_x_rel, accel_y_rel);
58 
59   double delta_time = ((millis() - last_call)/1000\&.0);
60   //double accel_x_abs = (accel_x_rel *  cos(theta) + accel_y_rel * sin(theta)) * delta_time;
61   //double accel_y_abs = (accel_y_rel *  cos(theta) + accel_x_rel * sin(theta)) * delta_time;
62 
63   //vel_acumm_x += accel_x_abs;
64   //vel_acumm_y += accel_y_abs;
65 
66   //double new_x = x + vel_acumm_x * delta_time;
67   //double new_y = y + vel_acumm_y * delta_time;
68 
69   struct accelerometer_odometry od;
70   //od\&.x = new_x;
71   //od\&.y = new_y;
72   return od;
73 }
.fi
.SS "static double calculate_angle ()\fC [static]\fP"

.SS "static double calculate_gryo_anglular_velocity ()\fC [static]\fP"

.PP
Definition at line 81 of file localization\&.c\&.
.PP
References g1, gyroGet(), and LOCALIZATION_UPDATE_FREQUENCY\&.
.PP
.nf
81                                                  {
82   static int last_gyro = 0;
83   int current = gyroGet(g1);
84   // Calculate w (angluar velocity in degrees per second)
85   double w = (current - last_gyro) / (LOCALIZATION_UPDATE_FREQUENCY/1000\&.0);
86   return w;
87 }
.fi
.SS "struct \fBlocation\fP get_position ()"

.PP
Gets the current posituion of the robot\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgyro1\fP The first gyro 
.RE
.PP
\fBReturns:\fP
.RS 4
the loacation of the robot as a struct\&. 
.RE
.PP

.PP
Definition at line 25 of file localization\&.c\&.
.PP
.nf
25                                {
26 
27 }
.fi
.SS "bool init_localization (const unsigned char gyro1, unsigned short multiplier, int start_x, int start_y, int start_theta)"

.PP
Starts the localization process\&. 
.PP
\fBAuthor:\fP
.RS 4
Chris Jerrett
.RE
.PP
\fBParameters:\fP
.RS 4
\fIgyro1\fP The first gyro  The multiplier parameter can tune the gyro to adapt to specific sensors\&. The default value at this time is 196; higher values will increase the number of degrees reported for a fixed actual rotation, while lower values will decrease the number of degrees reported\&. If your robot is consistently turning too far, increase the multiplier, and if it is not turning far enough, decrease the multiplier\&. 
.RE
.PP

.PP
Definition at line 89 of file localization\&.c\&.
.PP
References g1, gyroInit(), last_call, localization_task, LOCALIZATION_UPDATE_FREQUENCY, makeMatrix(), millis(), taskRunLoop(), and update_position()\&.
.PP
.nf
89                                                                                                                          {
90   g1 = gyroInit(gyro1, multiplier);
91   //init state matrix
92 
93   //one dimensional vector with x, y, theta, acceleration in x and y
94   state_matrix = makeMatrix(1, 5);
95   localization_task = taskRunLoop(update_position, LOCALIZATION_UPDATE_FREQUENCY * 1000);
96   last_call = millis();
97   return true;
98 }
.fi
.SS "static double integrate_gyro_w (int new_w)\fC [static]\fP"

.PP
Definition at line 75 of file localization\&.c\&.
.PP
References LOCALIZATION_UPDATE_FREQUENCY, and encoder_odemtry::theta\&.
.PP
.nf
75                                           {
76   static double theta = 0;
77   double delta_theta = new_w * LOCALIZATION_UPDATE_FREQUENCY;
78   theta += delta_theta;
79 }
.fi
.SS "void update_position ()"

.PP
Definition at line 29 of file localization\&.c\&.
.PP
References calculate_accelerometer_odemetry(), last_call, and millis()\&.
.PP
Referenced by init_localization()\&.
.PP
.nf
29                        {
30   //int curr_theta = calculate_angle();
31 
32   struct accelerometer_odometry oddem = calculate_accelerometer_odemetry();
33   //printf("x: %d y: %d T: %d\n", a\&.x, a\&.y, 0);
34 
35   /*int l = 1;
36   int vr = get_encoder_velocity(1);
37   int vl = get_encoder_velocity(2);
38   int theta_dot = (vr - vl) / l;
39   int curr_theta = theta + theta_dot;
40   double dt = LOCALIZATION_UPDATE_FREQUENCY;
41   double v_tot = (vr+vl)/2\&.0;
42   int x_curr = x - v_tot*dt*sin(curr_theta);
43   int y_curr = y + v_tot*dt*cos(curr_theta);
44   x = x_curr;
45   y = y_curr;*/
46   last_call = millis();
47 }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBGyro\fP g1\fC [static]\fP"

.PP
Definition at line 4 of file localization\&.c\&.
.PP
Referenced by calculate_gryo_anglular_velocity(), and init_localization()\&.
.SS "int last_call = 0\fC [static]\fP"

.PP
Definition at line 7 of file localization\&.c\&.
.PP
Referenced by calculate_accelerometer_odemetry(), init_localization(), and update_position()\&.
.SS "\fBTaskHandle\fP localization_task\fC [static]\fP"

.PP
Definition at line 5 of file localization\&.c\&.
.PP
Referenced by init_localization()\&.
.SS "\fBmatrix\fP* state_matrix"

.PP
Definition at line 9 of file localization\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Vex Team 9228A from the source code\&.
